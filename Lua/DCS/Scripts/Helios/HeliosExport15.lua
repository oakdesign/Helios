-- ========================= HELIOS EXPORT ======================================
--
-- This file is GENERATED by Helios 1.5 Profile Editor.
-- You should not need to edit this file in most casees.
--
-- [Integration instructions to follow here]
--

-- ========================= CONFIGURATION ======================================

-- global scope for Helios public API, which is the code and state available to vehicle driver scripts
helios = {}
helios.version = "1.5.0"

-- local scope for privileged interface used for testing
local helios_impl = {}

-- local scope for private code, to avoid name clashes
local helios_private = {}

-- report start up before configuration happens
log.write("HELIOS.EXPORT", log.INFO, string.format("initializing Helios Export script version %s", helios.version))

-- ========================= CONFIGURATION ======================================

-- address to which we send
helios_private.host = "127.0.0.1"

-- UDP port to which we send
-- NOTE: our local port on which we listen is dynamic
helios_private.port = 9089

-- how many export intervals have to pass before we send low priority data again
helios_private.exportLowTickInterval = 2

-- seconds before we load a profile even if we don't hear from Helios
helios_impl.autoLoadDelay = 3.0

-- seconds between ticks (high priority export interval)
helios_impl.exportInterval = 0.067

-- maximum number of seconds without us sending anything
-- NOTE: Helios needs us to send something to discover our UDP client port number
helios_impl.announceInterval = 3.0

-- seconds between announcements immeidately after change in vehicle, to give
-- Helios a chance to discover us after it restarts its interface
helios_impl.fastAnnounceInterval = 0.1

-- seconds after change in vehicle to use fast announcements
helios_impl.fastAnnounceDuration = 1.0

-- seconds between checks whether this file has changed, if hot reload is enabled
helios_impl.hotReloadInterval = 5.0

-- Module names are different from internal self names, so this table translates them
-- without instantiating every module.  Planes must be entered into this table to be
-- able to use modules from the Scripts\Mods directory.
local helios_module_names = {
    ["A-10C"] = "Helios_A10C",
    ["F-14B"] = "Helios_F14",
    ["F-16C_50"] = "Helios_F16C",
    ["FA-18C_hornet"] = "Helios_F18C",
    ["A-10A"] = "Helios_FC",
    ["F-15C"] = "Helios_FC",
    ["MiG-29"] = "Helios_FC",
    ["Su-25"] = "Helios_FC",
    ["Su-27"] = "Helios_FC",
    ["Su-33"] = "Helios_FC",
    ["AV8BNA"] = "Helios_Harrier",
    ["UH-1H"] = "Helios_Huey",
    ["Ka-50"] = "Helios_KA50",
    ["L-39"] = "Helios_L39",
    ["Mi-8MT"] = "Helios_MI8",
    ["MiG-21Bis"] = "Helios_Mig21Bis",
    ["P-51D"] = "Helios_P51",
    ["TF-51D"] = "Helios_P51",
    ["SA342"] = "Helios_SA342"
}

-- ========================= HOOKS CALLED BY DCS =================================

-- local scope for DCS callbacks
local helios_dcs = {}

-- DCS Export Functions
function helios_dcs.LuaExportStart()
    -- called once just before mission start.
    package.path = package.path .. ";.\\LuaSocket\\?.lua"
    package.cpath = package.cpath .. ";.\\LuaSocket\\?.dll"

    helios_impl.init()
end

function helios_dcs.LuaExportBeforeNextFrame()
    helios_private.processInput()
end

function helios_dcs.LuaExportAfterNextFrame()
end

function helios_dcs.LuaExportStop()
    -- called once just after mission stop.
    helios_impl.unload()
end

function helios_dcs.LuaExportActivityNextEvent(timeNow)
    local previousClock = helios_private.clock
    helios_private.clock = timeNow
    if previousClock == 0 then
        -- we just learned the time for the first time
        helios_private.initTimers()
    end
    local nextEvent = timeNow + helios_impl.exportInterval

    -- process timers
    for timerName, timer in pairs(helios_private.state.timers) do
        if timer ~= nil then
            -- log.write(
            --     "HELIOS.EXPORT",
            --     log.DEBUG,
            --     string.format("active timer %s at %f, clock is %f", timerName, timer, clock)
            -- )
            if helios_private.clock >= timer then
                -- timer expired
                if timerName == "autoLoad" then
                    helios_private.state.timers.autoLoad = nil
                    helios_private.autoLoad()
                elseif timerName == "reload" then
                    if helios_private.checkReload() then
                        -- all our functions and state were just reset, so don't do anything
                        -- and get called again right away
                        return nextEvent + 1
                    end
                end
            else
                if timer < nextEvent then
                    -- need to wake up for this
                    nextEvent = timer
                end
            end
        end
    end

    -- check if vehicle type has changed
    local selfName = helios.selfName()
    if selfName ~= helios_private.previousSelfName then
        helios_private.handleSelfNameChange(selfName)
    end

    -- count until we need to send low priority data
    helios_private.state.tickCount = helios_private.state.tickCount + 1

    if helios_private.driver.processExports ~= nil then
        -- let driver do it
        helios_private.driver.processExports(LoGetSelfData())
    else
        helios_private.processExports()
    end

    local heartBeat = false
    if helios_private.clock > (helios_impl.announceInterval + helios_private.state.lastSend) then
        -- if we sent nothing for a long time, send something just to let Helios discover us
        heartBeat = true
    end
    if helios_private.state.fastAnnounceTicks > 0 then
        -- immediately after changing vehicle or otherwise resetting, announce very fast
        helios_private.state.fastAnnounceTicks = helios_private.state.fastAnnounceTicks - 1
        if helios_private.clock > (helios_impl.fastAnnounceInterval + helios_private.state.lastSend) then
            heartBeat = true
        end
    end

    if heartBeat then
        log.write("HELIOS.EXPORT", log.DEBUG, string.format("sending alive announcement after %f seconds without any data sent (clock %f, sent %f)",
            helios_impl.announceInterval,
            helios_private.clock,
            helios_private.state.lastSend
        ))
        helios_private.doSend("ALIVE", "")
    end

    helios_private.flush();
    return nextEvent
end

-- ========================= PUBLIC API FOR PROFILE DRIVERS ======================

function helios.splitString(str, delim, maxNb)
    -- quickly handle edge case
    if string.find(str, delim) == nil then
        return { str }
    end

    -- optional limit on number of fields
    if maxNb == nil or maxNb < 1 then
        maxNb = 0 -- No limit
    end
    local result = {}
    local pat = "(.-)" .. delim .. "()"
    local nb = 0
    local lastPos
    for part, pos in string.gfind(str, pat) do
        nb = nb + 1
        result[nb] = part
        lastPos = pos
        if nb == maxNb then
            break
        end
    end
    -- Handle the last field
    if nb ~= maxNb then
        result[nb + 1] = string.sub(str, lastPos)
    end
    return result
end

function helios.round(num, idp)
    local mult = 10 ^ (idp or 0)
    return math.floor(num * mult + 0.5) / mult
end

function helios.ensureString(s)
    if type(s) == "string" then
        return s
    else
        return ""
    end
end

function helios.textureToString(s)
    if s == nil then
        return "0"
    else
        return "1"
    end
end

function helios.parseIndication(indicator_id)
    -- Thanks to [FSF]Ian code
    local ret = {}
    local li = list_indication(indicator_id)
    if li == "" then
        return nil
    end
    local m = li:gmatch("-----------------------------------------\n([^\n]+)\n([^\n]*)\n")
    while true do
        local name, value = m()
        if not name then
            break
        end
        ret[name] = value
    end
    return ret
end

-- send a value if its value has changed, batching sends
function helios.send(id, value)
    if string.len(value) > 3 and value == string.sub("-0.00000000", 1, string.len(value)) then
        value = value:sub(2)
    end
    if helios_private.state.lastData[id] == nil or helios_private.state.lastData[id] ~= value then
        helios_private.doSend(id, value)
        helios_private.state.lastData[id] = value
    end
end

-- currently active vehicle/airplane
function helios.selfName()
    local info = LoGetSelfData()
    if info == nil then
        return ""
    end
    return info.Name
end

-- ========================= TESTABLE IMPLEMENTATION =============================
-- These functions are exported for use in mock testing, but are not for use by
-- profile drivers or modules.  Keeping their interface stable allows the mock tester to continue
-- to work.

-- called either from LuaExportStart hook or from hot reload
function helios_impl.init()
    -- load socket library, if not already done
    helios_private.socketLibrary = helios_private.socketLibrary or require("socket")

    -- Simulation id
    helios_private.simID = string.format("%08x*", os.time())

    -- most recently detected selfName
    helios_private.previousSelfName = ""

    -- event time 'now' as told to us by DCS
    helios_private.clock = 0

    -- init with empty driver that exports nothing by default
    -- NOTE: also clears state
    helios_impl.installDriver(helios_private.createDriver(), "")

    -- start service
    helios_private.clientSocket = helios_private.socketLibrary.udp()
    helios_private.clientSocket:setsockname("*", 0)
    helios_private.clientSocket:setoption("broadcast", true)
    helios_private.clientSocket:settimeout(.001) -- blocking, but for a very short time

    -- if we are reloaded, we have to start using the new copies of these functions,
    -- because they are bound to the new private variables
    if helios_loader ~= nil then
        helios_loader.reload = helios_private.reload
        helios_loader.scriptChanged = helios_private.scriptChanged
    end
end

function helios_impl.unload()
    -- flush pending data, send DISCONNECT message so we can fire the Helios Disconnect event
    helios_private.doSend("DISCONNECT", "")
    helios_private.flush()

    -- free file descriptor and release port
    helios_private.clientSocket:close()
end

-- for hot reload, we also need to step out of the DCS hook chain
function helios_impl.unhook()
    helios_private.unhookDCS()
end

-- handle incoming message from Helios
function helios_impl.dispatchCommand(command)
    -- REVISIT: this is legacy code and does not guard anything
    local commandCode = string.sub(command, 1, 1)
    local rest = string.sub(command, 2):match("^(.-)%s*$");
    if (commandCode == "P") then
        local profileName = rest
        helios_impl.loadProfile(helios.selfName(), profileName)
    elseif helios_private.driver.processInput ~= nil then
        -- delegate commands other than 'P'
        helios_private.driver.processInput(command)
    elseif commandCode == "R" then
        -- reset command from Helios requests that we consider all values dirty
        helios_private.resetCachedValues()
    elseif (commandCode == "C") then
        -- click command from Helios
        local commandArgs = helios.splitString(rest, ",")
        local targetDevice = GetDevice(commandArgs[1])
        if type(targetDevice) == "table" then
            targetDevice:performClickableAction(commandArgs[2], commandArgs[3])
        end
    end
end

-- cancel any pending auto load
function helios_impl.cancelAutoLoad()
    helios_private.state.timers.autoLoad = nil
end

-- load the export profile for the vehicle (DCS info name of the vehicle) and profile short name, not including .lua extension
function helios_impl.loadProfile(selfName, profileName)
    local driver = helios_private.createDriver()
    local driverName = ""
    local success, result

    -- cancel any pending auto load
    helios_impl.cancelAutoLoad();

    -- check if request is allowed
    local currentSelfName = helios.selfName()
    if currentSelfName ~= selfName then
        success = false
        result = string.format("cannot load profile '%s' while vehicle '%s' is active", profileName, currentSelfName)
        -- fall through to tell Helios to choose something that makes sense
    -- check if request is already satisfied
    elseif helios_impl.driverName == profileName then
        -- do nothing
        log.write("HELIOS.EXPORT", log.INFO, string.format("profile driver '%s' for '%s' is already loaded", profileName, selfName))
        helios_impl.notifyLoaded()
        return
    else
        -- now try to load specific profile
        local driverPath = string.format("%sScripts\\Helios\\Drivers\\%s\\%s.lua", lfs.writedir(), selfName, profileName)
        success, result = pcall(dofile, driverPath)

        if not success then
            log.write("HELIOS.EXPORT", log.INFO, string.format("failed to load profile driver for %s from %s", selfName, driverPath))
        end

        -- if the driver is not found, try a module
        if (not success) and helios_module_names[selfName] ~= nil then
            -- use export-everything module for this aircraft
            -- NOTE: this makes us compatible with Capt Zeen profiles
            local moduleName = helios_module_names[selfName]
            local module = helios_impl.createModuleDriver(selfName, moduleName)
            if module ~= nil then
                -- success
                log.write("HELIOS.EXPORT", log.INFO, string.format("loaded module '%s' for '%s'", moduleName, selfName))
                helios_impl.installDriver(module, moduleName)
                helios_impl.notifyLoaded()
                return
            else
                result = string.format("failed to load module '%s' for '%s'", moduleName, selfName)
            end
        end

        -- check result for nil, since profile may not have returned anything
        if success and result == nil then
            success = false
            result = string.format("driver %s did not return a profile object; incompatible with this export script",
                driverPath
            )
        end

        -- sanity check, make sure profile is for correct selfName, since race condition is possible
        if success and result.selfName ~= selfName then
            success = false
            result = string.format("driver %s is for incorrect vehicle '%s'",
                driverPath,
                result.selfName
            )
        end
    end

    if success then
        -- merge, replacing anything specified by the profile
        for k, v in pairs(result) do
            driver[k] = v
        end
        log.write("HELIOS.EXPORT", log.INFO, string.format("loaded profile driver '%s' for '%s'", profileName, driver.selfName))
        driverName = profileName
    else
        -- if the load fails, just leave the driver initialized to defaults
        log.write(
            "HELIOS.EXPORT",
            log.WARNING,
            string.format("failed to load profile driver '%s' for '%s'; disabling interface", profileName, selfName)
        )
        log.write("HELIOS.EXPORT", log.WARNING, result)
    end

    -- actually install the driver
    helios_impl.installDriver(driver, driverName)

    -- tell Helios about it
    helios_impl.notifyLoaded()

    if not success then
        -- solicit matching profile
        helios_private.notifySelfName(currentSelfName)
    end
end

function helios_impl.installDriver(driver, driverName)
    -- shut down any existing driver
    if helios_private.driver ~= nil then
        helios_private.driver.unload()
        helios_private.driver = nil
    end

    -- install driver
    driver.init()
    helios_private.driver = driver
    helios_impl.driverName = driverName

    -- drop any remmaining data and mark all values as dirty
    helios_private.clearState()
end

function helios_impl.notifyLoaded()
    -- export code for 'currently active vehicle, reserved across all DCS interfacess
    log.write("HELIOS.EXPORT", log.INFO, string.format("notifying Helios of active driver '%s'", helios_impl.driverName))
    helios_private.doSend("ACTIVE_PROFILE", helios_impl.driverName)
    helios_private.flush()
end

-- enable hot reloading of the script on changes
function helios_impl.enableHotReload(fullPath)
    local attributes = lfs.attributes(fullPath)
    if attributes == nil then
        log.write("HELIOS.EXPORT", log.ERROR, string.format("hot reloading will not work because the specified file '%s' does not exist", fullPath))
        return
    end

    -- build a new global scope that does not get written when we reload
    helios_loader = {
        fullPath = fullPath,
        modified = attributes.modification,
        reload = helios_private.reload,
        scriptChanged = helios_private.scriptChanged
    }

    -- stubs we register as DCS callbacks during hot reload if we are the only script in the chain
    -- if we die on restart, these will remain as safe handlers
    function helios_loader.LuaExportStart() end
    function helios_loader.LuaExportStop() end
    function helios_loader.LuaExportActivityNextEvent(t) return t end
    function helios_loader.LuaExportBeforeNextFrame() end
    function helios_loader.LuaExportAfterNextFrame() end
end

-- for testing
function helios_impl.setSimID(value)
    helios_private.simID = value
end

-- ========================= PRIVATE CODE ========================================

-- luasocket
helios_private.socketLibrary = nil -- lazy init, but not reset on hot reload

function helios_private.clearState()
    helios_private.state = {}

    helios_private.state.packetSize = 0
    helios_private.state.sendStrings = {}
    helios_private.state.lastData = {}

    -- event time of last message sent
    helios_private.state.lastSend = 0

    -- Frame counter for non important data
    helios_private.state.tickCount = 0

    -- times at which we need to take a specific action
    helios_private.state.timers = {}

    -- ticks of fast announcement remaining
    helios_private.state.fastAnnounceTicks = helios_impl.fastAnnounceDuration / helios_impl.exportInterval

    -- restart timers if we know what time it is
    if helios_private.clock > 0 then
        helios_private.initTimers()
    end
end

function helios_private.processArguments(device, arguments)
    if arguments == nil then
        return
    end
    local lArgumentValue
    for lArgument, lFormat in pairs(arguments) do
        lArgumentValue = string.format(lFormat, device:get_argument_value(lArgument))
        helios.send(lArgument, lArgumentValue)
    end
end

-- sends without checking if the value has changed
function helios_private.doSend(id, value)
    local data = id .. "=" .. value
    local dataLen = string.len(data)

    if dataLen + helios_private.state.packetSize > 576 then
        helios_private.flush()
    end

    table.insert(helios_private.state.sendStrings, data)
    helios_private.state.packetSize = helios_private.state.packetSize + dataLen + 1
end

function helios_private.flush()
    if #helios_private.state.sendStrings > 0 then
        local packet = helios_private.simID .. table.concat(helios_private.state.sendStrings, ":") .. "\n"
        helios_private.socketLibrary.try(helios_private.clientSocket:sendto(packet, helios_private.host, helios_private.port))
        helios_private.state.lastSend = helios_private.clock
        helios_private.state.sendStrings = {}
        helios_private.state.packetSize = 0
    end
end

function helios_private.resetCachedValues()
    helios_private.state.lastData = {}

    -- make sure low priority is sent also
    helios_private.state.tickCount = helios_private.exportLowTickInterval
end

function helios_private.processInput()
    local lInput = helios_private.clientSocket:receive()

    if lInput then
        helios_impl.dispatchCommand(lInput)
    end
end

function helios_private.createDriver()
    -- defaults
    local driver = {}
    driver.selfName = ""
    driver.everyFrameArguments = {}
    driver.arguments = {}
    function driver.processHighImportance()
        -- do nothing
    end
    function driver.processLowImportance()
        -- do nothing
    end
    function driver.init()
        -- do nothing
    end
    function driver.unload()
        -- do nothing
    end
    return driver
end

function helios_private.notifySelfName(selfName)
    -- export code for 'currently active vehicle, reserved across all DCS interfacess
    log.write("HELIOS.EXPORT", log.INFO, string.format("notifying Helios of active vehicle '%s'", selfName))
    helios_private.doSend("ACTIVE_VEHICLE", selfName)
    helios_private.flush()
end

function helios_private.findProfiles(selfName)
    local numProfiles = 0
    local firstProfile = nil
    for path in lfs.dir(string.format("%sScripts\\Helios\\Drivers\\%s", lfs.writedir(), selfName)) do
        if path:match(".lua$") then
            log.write(
                "HELIOS.EXPORT",
                log.DEBUG,
                string.format("found %s", path)
            )
            if firstProfile == nil then
                firstProfile = path:gsub(".lua$", "")
            end
            numProfiles = numProfiles + 1
        end
    end
    return numProfiles, firstProfile
end

function helios_private.autoLoad()
    local selfName = helios.selfName()
    local numProfiles, firstProfile = helios_private.findProfiles(selfName)
    if numProfiles < 1 then
        -- deleted or maybe the type of vehicle changed
        log.write(
            "HELIOS.EXPORT",
            log.INFO,
            string.format("no profiles for vehicle '%s'; cannot automatically load profile", selfName)
        )
        return
    end
    log.write(
        "HELIOS.EXPORT",
        log.INFO,
        string.format("automatically loading first driver '%s' for '%s'", firstProfile, selfName)
    )
    helios_impl.loadProfile(selfName, firstProfile)
end

function helios_private.handleSelfNameChange(selfName)
    log.write(
        "HELIOS.EXPORT",
        log.INFO,
        string.format("changed vehicle from '%s' to '%s'", helios_private.previousSelfName, selfName)
    )
    helios_private.notifySelfName(selfName)
    helios_private.previousSelfName = selfName

    -- no matter what, the current driver is done
    helios_private.clearState()
    helios_impl.installDriver(helios_private.createDriver(), "")

    -- check applicable profiles
    local numProfiles, firstProfile = helios_private.findProfiles(selfName)
    if numProfiles > 1 then
        -- if there are multiple profiles for self.name, then load [none] driver, and set timer
        -- 		export using [none] driver (do nothing)
        -- 		if timer expires before Helios specifies profile, then load first profile for self.name
        log.write(
            "HELIOS.EXPORT",
            log.INFO,
            string.format("%d profiles for vehicle '%s'; waiting up to %f seconds for Helios", numProfiles, selfName, helios_impl.autoLoadDelay)
        )
        helios_private.state.timers.autoLoad = helios_private.clock + helios_impl.autoLoadDelay
        -- don't notify Helios, we will silently wait
    elseif numProfiles == 1 then
        -- exactly one driver applies, so we don't have to wait
        -- NOTE: this makes us more compatible with legacy Helios
        -- NOTE: this handles notification also
        helios_impl.loadProfile(selfName, firstProfile)
    elseif helios_module_names[selfName] ~= nil then
        -- use export-everything module for this aircraft
        -- NOTE: this makes us compatible with Capt Zeen profiles
        local moduleName = helios_module_names[selfName]
        local driver = helios_impl.createModuleDriver(selfName, moduleName)
        if driver ~= nil then
            helios_impl.installDriver(driver, moduleName)
        end
        -- if we fail, we just leave the empty driver installed
        -- either way, we need to tell Helios
        helios_impl.notifyLoaded()
    else
        log.write(
            "HELIOS.EXPORT",
            log.INFO,
            string.format("no profile or module for vehicle '%s'; disabling interface", selfName)
        )
        -- let Helios know we have a dummy driver loaded
        helios_impl.notifyLoaded()
    end
end

--- default implementation of exports, used if not overridden by the driver
function helios_private.processExports()
    local mainPanetargetDevice = GetDevice(0)
    if type(mainPanetargetDevice) == "table" then
        mainPanetargetDevice:update_arguments()

        helios_private.processArguments(mainPanetargetDevice, helios_private.driver.everyFrameArguments)
        helios_private.driver.processHighImportance(mainPanetargetDevice)

        if helios_private.state.tickCount >= helios_private.exportLowTickInterval then
            helios_private.processArguments(mainPanetargetDevice, helios_private.driver.arguments)
            helios_private.driver.processLowImportance(mainPanetargetDevice)
            helios_private.state.tickCount = 0
        end
    end
end

-- shut down and reload.  NOTE: we will get a new dynamic local port, so Helios will see this like a DCS restart
function helios_private.reload()
    log.write("HELIOS.EXPORT", log.INFO, string.format("hot reloading script '%s'", helios_loader.fullPath))
    helios_impl.unload()
    helios_impl.unhook()
    local success, result = pcall(dofile, helios_loader.fullPath)
    if success then
        -- install new version
        helios_impl = result
    else
        log.write("HELIOS.EXPORT", log.ERROR, string.format("hot reload of script '%s' failed", helios_loader.fullPath))
        if type(result) == "string" then
            log.write("HELIOS.EXPORT", log.ERROR, result)
        end
    end
    helios_impl.init()
    return helios_impl
end

-- check for file change on main script
function helios_private.scriptChanged()
    local previous = helios_loader.modified or 0
    local attributes = lfs.attributes(helios_loader.fullPath)
    if attributes == nil then
        if helios_loader.modified ~= nil then
            -- log this once
            log.write("HELIOS.EXPORT", log.ERROR, string.format("script '%s' is no longer accessible; hot reload will not work", helios_loader.fullPath))
            helios_loader.modified = nil
        end
        return false
    end
    helios_loader.modified = attributes.modification
    log.write("HELIOS.EXPORT", log.DEBUG, string.format("instance '%s' checking script '%s' modified at %d; previous version from %d",
        helios_private.simID,
        helios_loader.fullPath,
        helios_loader.modified,
        previous))
    return helios_loader.modified > (1 + previous)
end

-- called on our reload check timer, returns true if reloaded
function helios_private.checkReload()
    if helios_loader ~= nil then
        -- persist in case we reload now
        helios_loader.timer =  helios_private.clock + helios_impl.hotReloadInterval

        -- check for file change
        if helios_loader.scriptChanged() then
            -- reload everything
            helios_loader.reload()
            -- we are running an unnamed function at this point. tell caller to back out
            return true
        end
        -- we are still here, just check again later
        helios_private.state.timers.reload = helios_loader.timer
    else
        -- not supposed to happen
        log.write("HELIOS.EXPORT", log.ERROR, "hot reload disabled")
        helios_private.state.timers.reload = nil
    end
    return false
end

-- called when we first learn the clock time or when we reset the state
function helios_private.initTimers()
    log.write("HELIOS.EXPORT", log.DEBUG, string.format("initializing timers at (clock %f)", helios_private.clock))
    if helios_loader ~= nil then
        if helios_loader.timer ~= nil then
            -- restore timer
            helios_private.state.timers.reload = helios_loader.timer
        else
            -- start new one
            helios_private.state.timers.reload =  helios_private.clock + helios_impl.hotReloadInterval
            -- persist
            helios_loader.timer = helios_private.state.timers.reload
        end
    end
end

-- ========================= MODULE COMPATIBILITY LAYER ==========================

-- for modules, this will be global scope Helios_Udp
local helios_modules_udp = {
}

-- for modules, this will be global scope Helios_Util
local helios_modules_util = {
}

function helios_impl.createModuleDriver(selfName, moduleName)
    local driver = helios_private.createDriver()
    driver.moduleName = moduleName

    function driver.init()
        -- prepare environment
        Helios_Udp = helios_modules_udp;
        Helios_Util = helios_modules_util;
    end

    function driver.unload()
        Helios_Udp = nil
        Helios_Util = nil
        _G[moduleName] = nil -- luacheck: no global
    end

    -- execute module
    local modulePath = string.format("%sScripts\\Helios\\Mods\\%s.lua", lfs.writedir(), moduleName)
    local success, result = pcall(dofile, modulePath)
    if success then
        result = _G[moduleName] -- luacheck: no global
    end

    -- check result for nil, since profile may not have returned anything
    if success and result == nil then
        success = false
        result = string.format("module %s did not create module object %s; incompatible with this export script",
            modulePath, moduleName
        )
    end

    -- sanity check, make sure module is for correct selfName
    if success then
        local names = helios.splitString(result.Name, ";")
        local supported = false
        for _, name in pairs(names) do
            if name == selfName then
                supported = true
            end
        end
        if not supported then
            success = false
            result = string.format("module %s does not support '%s', only %s",
                moduleName,
                selfName,
                table.concat(names, ", ")
            )
        end
    end

    if not success then
        log.write('HELIOS EXPORT', log.DEBUG, string.format("could not create module driver '%s' for '%s'", moduleName, selfName))
        log.write('HELIOS EXPORT', log.DEBUG, result)
        return nil
    end

    -- hook it up
    driver.selfName = selfName
    driver.everyFrameArguments = result.HighImportanceArguments
    driver.arguments = result.LowImportanceArguments
    driver.processHighImportance = result.HighImportance
    driver.processLowImportance = result.LowImportance
    driver.processInput = result.ProcessInput
    if result.FlamingCliffsAircraft then
        -- override all export processing, even if no hook provided
        if result.ProcessExports ~= nil then
            driver.processExports = result.ProcessExports
        else
            function driver.processExports()
                -- do nothing
            end
        end
    end
    return driver
end

helios_modules_udp.Send = helios.send -- same signature
helios_modules_udp.Flush = helios_private.flush -- same signature
helios_modules_udp.ResetChangeValues = helios_private.resetCachedValues -- same signature

function helios_modules_util.Split(text, pattern)
    local ret = {}
    local findpattern = "(.-)"..pattern
    local last = 1
    local startpos, endpos, str = text:find(findpattern, 1)

    while startpos do
       if startpos ~= 1 or str ~= "" then table.insert(ret, str) end
       last = endpos + 1
       startpos, endpos, str = text:find(findpattern, last)
    end

    if last <= #text then
       str = text:sub(last)
       table.insert(ret, str)
    end

    return ret
end

function helios_modules_util.Degrees(radians)
    if radians == nil then
        return 0.0
    end
	return radians * 57.2957795
end

function helios_modules_util.Convert_Lamp(valor_lamp)
	return (valor_lamp  > 0.1) and 1 or 0
end

function helios_modules_util.Convert_SW (valor)
	return math.abs(valor-1)+1
end

function helios_modules_util.ValueConvert(actual_value, input, output)
	local range=1
	local slope = {}

	for a=1,#output-1 do -- calculating the table of slopes
		slope[a]= (input[a+1]-input[a]) / (output[a+1]-output[a])
	end

	for a=1,#output-1 do
		if actual_value >= output[a] and actual_value <= output[a+1] then
			range = a
			break
		end     -- check the range of the value
	end

	local final_value = ( slope[range] * (actual_value-output[range]) ) + input[range]
	return final_value
end

helios_modules_util.GetListIndicator = helios.parseIndication -- same signature

-- ========================= CONNECTION TO DCS ===================================

-- save and chain any previous exports
helios_private.previousHooks = {}
helios_private.previousHooks.LuaExportStart = LuaExportStart
helios_private.previousHooks.LuaExportStop = LuaExportStop
helios_private.previousHooks.LuaExportActivityNextEvent = LuaExportActivityNextEvent
helios_private.previousHooks.LuaExportBeforeNextFrame = LuaExportBeforeNextFrame
helios_private.previousHooks.LuaExportAfterNextFrame = LuaExportAfterNextFrame

-- utility to chain one DCS hook without arguments
function helios_private.chainHook(functionName)
    _G[functionName] = function() -- luacheck: no global
        -- try execute Helios version of hook
        local success, result = pcall(helios_dcs[functionName])
        if not success then
            log.write("HELIOS.EXPORT", log.ERROR, string.format("error return from Helios implementation of '%s'", functionName))
            if type(result) == "string" then
                log.write("HELIOS.EXPORT", log.ERROR, result)
            end
        end
        -- chain to next if it isn't our safety stub left over from reload
        local nextHandler = helios_private.previousHooks[functionName]
        if nextHandler ~= nil and nextHandler ~= helios_loader[functionName] then
            nextHandler()
        end
    end
end

-- hook all the basic functions without arguments
helios_private.chainHook("LuaExportStart")
helios_private.chainHook("LuaExportStop")
helios_private.chainHook("LuaExportAfterNextFrame")
helios_private.chainHook("LuaExportBeforeNextFrame")

-- specialized chain for next event hook
function LuaExportActivityNextEvent(timeNow)
    local timeNext = timeNow;

    -- try execute Helios version of hook
    local success, result = pcall(helios_dcs.LuaExportActivityNextEvent, timeNow)
    if success then
        timeNext = result
    else
        log.write("HELIOS.EXPORT", log.ERROR, string.format("error return from Helios implementation of 'LuaExportActivityNextEvent'"))
        if type(result) == "string" then
            log.write("HELIOS.EXPORT", log.ERROR, result)
        end
    end

    -- chain to next and keep closest event time that requires wake up
    -- chain only if it isn't our safety stub left over from reload
    local nextHandler = helios_private.previousHooks.LuaExportActivityNextEvent
    if nextHandler ~= nil and nextHandler ~= helios_loader.LuaExportActivityNextEvent then
        local timeOther = nextHandler(timeNow)
        if timeOther < timeNext then
            timeNext = timeOther
        end
    end
    return timeNext
end

-- on hot reload, remove our old implementation from the DCS hooks
function helios_private.unhookDCS()
    if helios_loader == nil then
        log.write("HELIOS.EXPORT", log.ERROR, string.format("logic error: attempted to use unhook without hot reload enabled; ignored"))
        return
    end

    -- if we die during restart, we need to keep things in a safe state
    -- these will catch any calls from our old hooks that other may have stored
    helios_dcs.LuaExportStart =  helios_loader.LuaExportStart
    helios_dcs.LuaExportStop = helios_loader.LuaExportStop
    helios_dcs.LuaExportActivityNextEvent = helios_loader.LuaExportActivityNextEvent
    helios_dcs.LuaExportBeforeNextFrame =  helios_loader.LuaExportBeforeNextFrame
    helios_dcs.LuaExportAfterNextFrame = helios_loader.LuaExportAfterNextFrame

    -- XXX this does not actually work, and possibly can't work.  other export scripts will have our previous
    -- hook stored and we don't indirect this hook through a global table, so it will call our old private code and crash
    -- XXX TODO try making helios_dcs an indirect table that is global and test with a chained export

    -- these functions must not suddenly become null, so we restore them or install
    -- a dummy handler if we are the only script
    LuaExportStart = helios_private.previousHooks.LuaExportStart or helios_loader.LuaExportStart
    LuaExportStop = helios_private.previousHooks.LuaExportStop or helios_loader.LuaExportStop
    LuaExportActivityNextEvent = helios_private.previousHooks.LuaExportActivityNextEvent or helios_loader.LuaExportActivityNextEvent
    LuaExportBeforeNextFrame = helios_private.previousHooks.LuaExportBeforeNextFrame or helios_loader.LuaExportBeforeNextFrame
    LuaExportAfterNextFrame = helios_private.previousHooks.LuaExportAfterNextFrame or helios_loader.LuaExportAfterNextFrame

    -- NOTE: some other script may have stored our old DCS hooks, but they will
    -- continue to work
end

-- when this script is being tested, these functions are accessible to our tester
return helios_impl