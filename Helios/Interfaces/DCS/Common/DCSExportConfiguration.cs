//  Copyright 2014 Craig Courtney
//    
//  Helios is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  Helios is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

using GadrocsWorkshop.Helios.UDPInterface;
using GadrocsWorkshop.Helios.Util;
using GadrocsWorkshop.Helios.Util.DCS;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Text;

namespace GadrocsWorkshop.Helios.Interfaces.DCS.Common
{
    /// <summary>
    /// Supported export module formats
    ///
    /// WARNING: the string representatio of these are used in the export protocol and must never be changed except by addition of new codes
    /// </summary>
    public enum DCSExportModuleFormat
    {
        // Description attribute: display string for use in UI
        [Description("Helios driver generated by this interface")]
        HeliosDriver16,

        // Description attribute: display string for use in UI
        [Description("Export module provided by Capt Zeen (Version 1)")]
        CaptZeenModule1
    }

    /// <summary>
    /// This object represents two related concepts:
    /// - Site configuration for the connection between the export script and Helios (IP address, port,
    /// update rate, which files are generated and where they are placed, etc.)
    /// - Generation of export files from a particular interface object
    /// These two aspects are not decoupled, because when used as a configuration object, it
    /// constantly recomputes the export files to see if they need to be regenerated.  So any attempt
    /// to separate the export file generation from the configuration object is of limited use.
    /// </summary>
    public class DCSExportConfiguration : DCSConfiguration
    {
        public class ModuleFormatInfo
        {
            public string DisplayName { get; internal set; }
            public string ModuleLocation { get; internal set; }
            public bool CanBeAttached { get; internal set; }
        }

        public static readonly Dictionary<DCSExportModuleFormat, ModuleFormatInfo> ExportModuleFormatInfo =
            new Dictionary<DCSExportModuleFormat, ModuleFormatInfo>
            {
                {
                    DCSExportModuleFormat.HeliosDriver16, new ModuleFormatInfo
                    {
                        // capitalization for use in a sentence (not at the beginning)
                        DisplayName = "Helios driver generated by this interface",
                        ModuleLocation = "Drivers",
                        CanBeAttached = false
                    }
                },
                {
                    DCSExportModuleFormat.CaptZeenModule1, new ModuleFormatInfo
                    {
                        // capitalization for use in a sentence (not at the beginning)
                        DisplayName = "export module provided by Capt Zeen (Version 1)",
                        ModuleLocation = "Mods",
                        CanBeAttached = true
                    }
                }
            };

        // the main export script we generate
        private const string EXPORT_MAIN_NAME = "HeliosExport16.lua";

        // the interface that owns this object, and for which we generate the Exports
        private readonly DCSInterface _parent;

        /// <summary>
        /// full Lua contents of Export.lua stub we sometimes install
        /// </summary>
        private string _exportStub = "";

        /// <summary>
        /// full Lua contents of EXPORT_SCRIPT_NAME
        /// </summary>
        private string _exportMain = "";

        /// <summary>
        /// full Lua contents of module for _parent
        /// </summary>
        private string _exportModuleText = "";

        /// <summary>
        /// IP address to which Export.lua will send UDP updates
        /// </summary>
        private string _ipAddress;

        /// <summary>
        /// Export.lua update ticks per second
        /// </summary>
        private int _exportFrequency;

        /// <summary>
        /// generate Export.lua stub or just Scripts/Helios/...?
        /// </summary>
        private bool _generateExportLoader;

        /// <summary>
        /// backing field for property CanAttachModuleFile, contains
        /// true if a module of the currently selected ExportModuleFormat can be attached
        /// </summary>
        private bool _canAttachModuleFile;

        /// <summary>
        /// backing field for property SelectedModuleFile, contains
        /// full path of the file selected for serialization into the attached module text
        /// </summary>
        private string _selectedModuleFile;

        /// <summary>
        /// backing field for property ModuleFolderGuess, contains
        /// our best guess for the folder where the module we might want to attach would be located
        /// </summary>
        private string _moduleFolderGuess;

        private static readonly NLog.Logger Logger = NLog.LogManager.GetCurrentClassLogger();

        public DCSExportConfiguration(DCSInterface parent)
        {
            _parent = parent;

            // get global configuration parameters that are not serialized to the profile
            _ipAddress = _parent.LoadSetting("IPAddress", "127.0.0.1");
            _exportFrequency = _parent.LoadSetting("ExportFrequency", 15);
            _generateExportLoader = _parent.LoadSetting("GenerateExportLoader", true);
            _exportModuleText = _parent.ExportModuleText;

            string savedDoFiles = _parent.LoadSetting("DoFiles", "");
            foreach (string file in savedDoFiles.Split(','))
            {
                if (!string.IsNullOrWhiteSpace(file))
                {
                    DoFiles.Add(file);
                }
            }

            // create our current config for status reporting
            UpdateConfiguration();

            // view model updates (this class provides simple view model support)
            UpdateViewModel();

            // register for changes:

            // if the UI changes our collection of dofiles, we recompute the exports
            DoFiles.CollectionChanged += DoFiles_CollectionChanged;

            // we recompute the exports if the collection of functions in our interface ever changes, in case there are any dynamic interfaces that change functions
            _parent.Functions.CollectionChanged += Functions_CollectionChanged;

            // location changes require us to recomput
            SubscribeToLocationChanges();

            // some properties in our parent object are relevant to us
            _parent.PropertyChanged += _parent_PropertyChanged;
        }

        private void _parent_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            switch (e.PropertyName)
            {
                case "ExportModuleFormat":
                case "ExportModuleBaseName":
                    Update();
                    break;
                case "ExportModuleText":
                    // we receive this indirectly like this in case change is from undo
                    _exportModuleText = _parent.ExportModuleText;
                    Update();
                    break;
            }
        }

        public override void Dispose()
        {
            base.Dispose();
            DoFiles.CollectionChanged -= DoFiles_CollectionChanged;
            _parent.Functions.CollectionChanged -= Functions_CollectionChanged;
        }

        private void DoFiles_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            // persist all children in changed collection to a single string
            _parent.SaveSetting("DoFiles", string.Join(",", DoFiles));
            Update();
        }

        private void Functions_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            // some bound functions in our interface have changed
            Update();
        }

        #region Properties

        /// <summary>
        /// true if a module of the currently selected ExportModuleFormat can be attached
        /// </summary>
        public bool CanAttachModuleFile
        {
            get => _canAttachModuleFile;
            set
            {
                if (_canAttachModuleFile == value)
                {
                    return;
                }

                bool oldValue = _canAttachModuleFile;
                _canAttachModuleFile = value;
                OnPropertyChanged("CanAttachModuleFile", oldValue, value, true);
            }
        }

        /// <summary>
        /// full path of the file selected for serialization into the attached module text
        /// </summary>
        public string SelectedModuleFile
        {
            get => _selectedModuleFile;
            set
            {
                if (_selectedModuleFile != null && _selectedModuleFile == value) return;
                string oldValue = _selectedModuleFile;
                _selectedModuleFile = value;
                if (value != null)
                {
                    // best guess if we try again is the same location
                    ModuleFolderGuess = Path.GetDirectoryName(value);

                    // try to read the file and include it
                    string moduleText = ReadFile(value);
                    using (new HeliosUndoBatch())
                    {
                        _parent.ExportModuleText = moduleText;
                        _parent.ExportModuleBaseName = Path.GetFileNameWithoutExtension(value);
                    }
                }
                else
                {
                    using (new HeliosUndoBatch())
                    {
                        _parent.ExportModuleText = null;
                        _parent.ExportModuleBaseName = null;
                    }
                }
                OnPropertyChanged("SelectedModuleFile", oldValue, value, true);
            }
        }

        private static string ReadFile(string inputPath)
        {
            using (StreamReader streamReader = new StreamReader(inputPath, new UTF8Encoding(false)))
            {
                return streamReader.ReadToEnd();
            }
        }

        private void WriteFile(string outputPath, string text)
        {
            using (StreamWriter streamWriter = new StreamWriter(outputPath, false, new UTF8Encoding(false)))
            {
                streamWriter.Write(text);
            }
        }

        /// <summary>
        /// Export.lua update ticks per second
        /// This is a site-specific setting persisted in HeliosSettings instead of in the profile.
        /// </summary>
        public int ExportFrequency
        {
            get => _exportFrequency;
            set
            {
                if (!_exportFrequency.Equals(value))
                {
                    int oldValue = _exportFrequency;
                    _exportFrequency = value;
                    _parent.SaveSetting("ExportFrequency", _exportFrequency);
                    OnPropertyChanged("ExportFrequency", oldValue, value, true);
                }
            }
        }

        /// <summary>
        /// Relative paths to files that Export.lua will call via dofile(...)
        /// This is a site-specific setting persisted in HeliosSettings instead of in the profile.
        /// </summary>
        public ObservableCollection<string> DoFiles { get; } = new ObservableCollection<string>();

        /// <summary>
        /// IP address to which Export.lua will send UDP updates
        /// This is a site-specific setting persisted in HeliosSettings instead of in the profile.
        /// </summary>
        public string IPAddress
        {
            get => _ipAddress;
            set
            {
                if (_ipAddress == null && value != null
                    || _ipAddress != null && !_ipAddress.Equals(value))
                {
                    string oldValue = _ipAddress;
                    _ipAddress = value;
                    _parent.SaveSetting("IPAddress", _ipAddress);
                    OnPropertyChanged("IPAddress", oldValue, value, false);
                }
            }
        }

        /// <summary>
        /// Port number to which Export.lua will send UDP updates
        /// This is a site-specific setting persisted in HeliosSettings instead of in the profile.
        /// </summary>
        public int Port
        {
            // we want Export.lua to send to our listening port
            get => _parent.Port;
            set
            {
                int oldValue = _parent.Port;
                if (!oldValue.Equals(value))
                {
                    _parent.Port = value;
                    _parent.SaveSetting("Port", value);
                    OnPropertyChanged("Port", oldValue, value, false);
                }
            }
        }

        /// <summary>
        /// If true, we generate the Scripts/Export.lua stub in addition to the files in Scripts/Helios
        /// This is a site-specific setting persisted in HeliosSettings instead of in the profile.
        /// </summary>
        public bool GenerateExportLoader
        {
            get => _generateExportLoader;
            set
            {
                bool oldValue = _generateExportLoader;
                if (oldValue == value)
                {
                    return;
                }

                _generateExportLoader = value;
                _parent.SaveSetting("GenerateExportLoader", _generateExportLoader);
                OnPropertyChanged("GenerateExportLoader", oldValue, value, false);
            }
        }

        /// <summary>
        /// our best guess for the folder where the module we might want to attach would be located
        /// </summary>
        public string ModuleFolderGuess
        {
            get => _moduleFolderGuess;
            set
            {
                if (_moduleFolderGuess != null && _moduleFolderGuess == value) return;
                string oldValue = _moduleFolderGuess;
                _moduleFolderGuess = value;
                OnPropertyChanged("ModuleFolderGuess", oldValue, value, true);
            }
        }

        /// <summary>
        /// backing field for property Status, contains
        /// the status of the configuration, including up to date, out of date, or lack of locations
        /// </summary>
        private StatusCodes _status;

        /// <summary>
        /// the status of the configuration, including up to date, out of date, or lack of locations
        /// </summary>
        public StatusCodes Status
        {
            get => _status;
            set
            {
                if (_status == value) return;
                StatusCodes oldValue = _status;
                _status = value;
                OnPropertyChanged("Status", oldValue, value, true);
            }
        }
        #endregion

        // view model functionality is embedded in this model class
        private void UpdateViewModel()
        {
            IList<InstallationLocation> locations = InstallationLocations.Singleton.Active;
            if (locations.Any())
            {
                // update this the guess if we can, otherwise just keep any guess we already might have
                ModuleFormatInfo moduleInfo = ExportModuleFormatInfo[_parent.ExportModuleFormat];
                ModuleFolderGuess = locations.First().ExportModuleDirectory(moduleInfo.ModuleLocation);
            }
            CanAttachModuleFile = ExportModuleFormatInfo[_parent.ExportModuleFormat].CanBeAttached;
        }

        private void UpdateConfiguration()
        {

            // reconfigure everything
            UpdateDirectories();
            UpdateExportStub();
            UpdateExportScript();
            UpdateModule();
        }

        protected override void Update()
        {
            UpdateConfiguration();
            UpdateViewModel();
            _parent.InvalidateStatusReport();
        }

        /// <summary>
        /// main entry point to write all generated files
        /// </summary>
        /// <returns>true if everything was written without error</returns>
        public override InstallationResult Install(IInstallationCallbacks callbacks)
        {
            try
            {
                ModuleFormatInfo moduleInfo = ExportModuleFormatInfo[_parent.ExportModuleFormat];
                List<StatusReportItem> report = new List<StatusReportItem>();

                // pass1: get permissions
                foreach (InstallationLocation location in InstallationLocations.Singleton.Active)
                {
                    if (_generateExportLoader)
                    {
                        string exportStubPath = location.ExportStubPath;
                        if (File.Exists(exportStubPath))
                        {
                            string contents = ReadFile(exportStubPath);
                            if (contents != _exportStub)
                            {
                                InstallationPromptResult response = callbacks.DangerPrompt("Overwrite Export.lua",
                                    $"Helios is about to overwrite the Export.lua script \nat {exportStubPath}\nThis file could have been created by third party software or a previous version.  Please make sure you have saved this file if you still need its contents.", new List<StatusReportItem>());
                                if (response == InstallationPromptResult.Cancel)
                                {
                                    // abort
                                    return InstallationResult.Canceled;
                                }
                            }
                        }
                    }
                }

                // pass2: do the writes
                foreach (InstallationLocation location in InstallationLocations.Singleton.Active)
                {
                    // create deepest folder
                    if (!Directory.Exists(location.ExportModuleDirectory(moduleInfo.ModuleLocation)))
                    {
                        Directory.CreateDirectory(location.ExportModuleDirectory(moduleInfo.ModuleLocation));
                    }

                    // write all the generated files
                    if (_generateExportLoader)
                    {
                        string exportStubPath = location.ExportStubPath;
                        WriteFile(exportStubPath, _exportStub);
                        report.Add(new StatusReportItem
                        {
                            Status = $"Wrote Export.Lua stub for {location.SavedGamesName}",
                            Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                        });
                    }

                    // main export script is required
                    File.WriteAllText(location.ExportMainPath(EXPORT_MAIN_NAME), _exportMain);
                    report.Add(new StatusReportItem
                    {
                        Status = $"Wrote main export file {EXPORT_MAIN_NAME} for {location.SavedGamesName}",
                        Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                    });

                    if (string.IsNullOrEmpty(_exportModuleText))
                    {
                        // not embedded module, we are done
                        continue;
                    }

                    string baseName = GenerateModuleBaseName();
                    File.WriteAllText(
                        location.ExportModulePath(moduleInfo.ModuleLocation, baseName),
                        _exportModuleText);
                    report.Add(new StatusReportItem
                    {
                        Status = $"Wrote {moduleInfo.DisplayName} for {baseName} to {location.SavedGamesName}",
                        Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                    });
                }

                // update status after all writes
                Update();
                callbacks.Success("Configuration of exports succeeded",
                    "All configured DCS locations were updated with Export.lua and all related scripts", report);
                return InstallationResult.Success;
            }
            catch (Exception ex)
            {
                Logger.Error(ex, "Failed to write DCS Export scripts due to error");
                callbacks.Failure("Failed to write DCS Export scripts due to error", ex.StackTrace,
                    new List<StatusReportItem>());
                return InstallationResult.Fatal;
            }
        }

        /// <summary>
        /// utility for checking if everything is up to date while editing in the UI,
        /// which is not the same as performing the ready check at run time
        /// </summary>
        /// <returns></returns>
        internal IList<StatusReportItem> CheckConfig()
        {
            List<StatusReportItem> report = new List<StatusReportItem>();
            IList<InstallationLocation> installationLocations = InstallationLocations.Singleton.Active;
            if (!installationLocations.Any())
            {
                report.Add(new StatusReportItem
                {
                    Status = "No DCS installation locations are configured for exports configuration",
                    Recommendation = "Configure any DCS installation directories you use",
                    Severity = StatusReportItem.SeverityCode.Error
                });
                Status = StatusCodes.NoLocations;
                return report;
            }

            // export.lua generation is optional, so we have to pick the correct function to check it
            Func<InstallationLocation, StatusReportItem> stubChecker;
            if (GenerateExportLoader)
            {
                stubChecker = CheckExportStub;
            }
            else
            {
                stubChecker = CheckThirdPartyExportStub;
            }

            foreach (InstallationLocation location in installationLocations)
            {
                List<Func<InstallationLocation, StatusReportItem>> checks =
                    new List<Func<InstallationLocation, StatusReportItem>>
                    {
                        CheckDirectories,
                        stubChecker,
                        CheckExportScript
                    };

                checks.Add(CheckModule);

                foreach (Func<InstallationLocation, StatusReportItem> check in checks)
                {
                    StatusReportItem result = check(location);
                    report.Add(result);
                    if (!result.Flags.HasFlag(StatusReportItem.StatusFlags.ConfigurationUpToDate))
                    {
                        Logger.Debug(result.Status);
                        Status = StatusCodes.OutOfDate;
                        // don't test the remaining items
                        return report;
                    }
                }
            }

            // finished
            Status = StatusCodes.UpToDate;
            return report;
        }

        /// <summary>
        /// main entry point for run time readiness check with a human readable narrative
        /// </summary>
        /// <returns></returns>
        public override IEnumerable<StatusReportItem> PerformReadyCheck()
        {
            string reportingName = _parent.ImpersonatedVehicleName ?? _parent.VehicleName;

            // XXX check if IP address is valid

            // check IP address to see if the files are are checking are actually used
            if (LocalMachineIsRemoteHelios())
            {
                yield return new StatusReportItem
                {
                    Status =
                        $"This computer may not be where DCS runs, because Exports are sent here via IP address {IPAddress}",
                    Recommendation =
                        "Helios cannot check that the export files have been copied to your computer running DCS",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                };
            }

            IList<InstallationLocation> installationLocations = InstallationLocations.Singleton.Active;
            if (!installationLocations.Any())
            {
                yield return new StatusReportItem
                {
                    Status = "No DCS installation locations are configured for exports configuration",
                    Recommendation = "Configure any DCS installation directories you use",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            foreach (InstallationLocation location in installationLocations)
            {
                // check on the Export.lua stub, if applicable
                if (GenerateExportLoader)
                {
                    UpdateExportStub();
                    yield return CheckExportStub(location);
                }
                else
                {
                    yield return CheckThirdPartyExportStub(location);
                }

                // check on our main script
                UpdateExportScript();
                yield return CheckExportScript(location);

                if (string.IsNullOrEmpty(_parent.ExportModuleBaseName))
                {
                    yield return new StatusReportItem
                    {
                        Status = $"DCS exports for {reportingName} are provided by a third party export module",
                        Recommendation = "Please manually check that the export module was correctly placed",
                        Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                    };
                    if (reportingName != _parent.VehicleName)
                    {
                        yield return new StatusReportItem
                        {
                            Status =
                                $"DCS Interface for {reportingName} requires a module that maps to the {_parent.VehicleName} interface",
                            Recommendation = "Please manually check that you are using an appropriate export module",
                            Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                        };
                    }
                }
                else
                {
                    UpdateModule();
                    yield return CheckModule(location);
                }
            }
        }

        #region ExportGenerators

        private void UpdateDirectories()
        {
            // this does nothing, directories are created when we write
        }

        private void UpdateExportStub()
        {
            _exportStub =
                Resources.ReadResourceFile("pack://application:,,,/Helios;component/Interfaces/DCS/Common/Export.lua")
                + string.Join("\n", GenerateDoFileLines());
        }

        private void UpdateExportScript()
        {
            _exportMain = Resources
                .ReadResourceFile($"pack://application:,,,/Helios;component/Interfaces/DCS/Common/{EXPORT_MAIN_NAME}")
                .Replace("HELIOS_REPLACE_IPAddress", IPAddress)
                .Replace("HELIOS_REPLACE_Port", Port.ToString())
                .Replace("HELIOS_REPLACE_ExportInterval", Math.Round(1d / Math.Max(4, ExportFrequency), 3).ToString());
        }

        private void UpdateModule()
        {
            switch (_parent.ExportModuleFormat)
            {
                case DCSExportModuleFormat.HeliosDriver16:
                    // NOTE: if this is refactored, continue to ensure that nothing is 
                    // written to _exportDriver if any component throws
                    _exportModuleText =
                        string.Join("\n", GenerateDriverLines())
                        + FetchExportFunctions()
                        + "\nreturn driver";
                    break;
                case DCSExportModuleFormat.CaptZeenModule1:
                    // nothing to do
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private string GenerateFunction(DCSDataElement element) => $"[{element.ID}]=\"{element.Format}\"";

        private IEnumerable<string> GenerateFunctions(bool everyFrame)
        {
            foreach (NetworkFunction function in _parent.Functions)
            foreach (ExportDataElement element in function.GetDataElements())
            {
                if (element is DCSDataElement dcsElement)
                {
                    if (dcsElement.Format != null && dcsElement.IsExportedEveryFrame == everyFrame)
                    {
                        yield return GenerateFunction(dcsElement);
                    }
                }
            }
        }

        private IEnumerable<string> GenerateDriverLines()
        {
            yield return $"-- export driver for {_parent.VehicleName} generated by Helios Profile Editor";
            yield return "local driver = { }";
            yield return $"driver.selfName = \"{_parent.VehicleName}\"";
            yield return "driver.everyFrameArguments = { ";
            yield return $"  {string.Join(",", GenerateFunctions(true))}";
            yield return "}";
            yield return "driver.arguments = { ";
            yield return $"  {string.Join(",", GenerateFunctions(false))}";
            yield return "}";
            yield return "";
        }

        private IEnumerable<string> GenerateDoFileLines()
        {
            int index = 1;
            foreach (string file in DoFiles)
            {
                // generate a local to hold a reference to anything the dofile returns, to
                // ensure its lifetime and report result in case of error
                yield return $"local helios_dofile_{index} = {{ }}";
                yield return $"helios_dofile_{index}.success, helios_dofile_{index}.result = pcall(dofile, \"{file}\")";
                yield return
                    $"if not helios_dofile_{index}.success then log.write(\"HELIOS.EXPORT\", log.ERROR, string.format(\"error return from configured external '{file}': %s\", tostring(helios_dofile_{index}.result))) end";
                index++;
            }
        }

        private string FetchExportFunctions()
        {
            if (string.IsNullOrWhiteSpace(_parent.ExportFunctionsPath))
            {
                return "";
            }

            try
            {
                return Resources.ReadResourceFile(_parent.ExportFunctionsPath);
            }
            catch (Exception ex)
            {
                Logger.Error(ex, $"failed to load interface-specific functions for {_parent.VehicleName} from '{_parent.ExportFunctionsPath}'");
                throw;
            }
        }

        #endregion

        #region ExportChecks

        private StatusReportItem CheckDirectories(InstallationLocation location)
        {
            string path = location.ScriptDirectoryPath;
            if (!Directory.Exists(path))
            {
                return new StatusReportItem
                {
                    Status = $"Export scripts have not been generated for {location.SavedGamesName}",
                    Recommendation = $"Select the interface for {_parent.VehicleName} and run DCS setup",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            return new StatusReportItem
            {
                Status = $"Export scripts location for {location.SavedGamesName} exists",
                Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate | StatusReportItem.StatusFlags.Verbose
            };
        }

        // NOTE: we don't factor this to share code with the other Check... functions because they are all
        // subtly different in terms of severity and we want to encourage more special cases added in the future
        private StatusReportItem CheckExportStub(InstallationLocation location)
        {
            string exportLuaPath = location.ExportStubPath;
            if (!File.Exists(exportLuaPath))
            {
                return new StatusReportItem
                {
                    Status = $"The configured DCS Export.lua stub does not exist at '{exportLuaPath}'",
                    Recommendation =
                        "Configure the DCS interface or configure install location correctly to locate the file",
                    Link = StatusReportItem.ProfileEditor,
                    // survive this
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            // NOTE: we have the entire contents we expect in this file in memory, so there is no point in hashing this
            string contents = ReadFile(exportLuaPath);
            if (!contents.Equals(_exportStub))
            {
                return new StatusReportItem
                {
                    Status = $"The DCS Export.lua stub at '{exportLuaPath}' does not match configuration",
                    Recommendation = $"Select the interface for {_parent.VehicleName} and run DCS setup",
                    Link = StatusReportItem.ProfileEditor,
                    // survive this
                    Severity = StatusReportItem.SeverityCode.Warning
                };
            }

            return new StatusReportItem
            {
                Status = $"The configured DCS Export.lua stub at '{exportLuaPath}' is up to date",
                Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
            };
        }

        // NOTE: we don't factor this to share code with the other Check... functions because they are all
        // subtly different in terms of severity and we want to encourage more special cases added in the future
        private StatusReportItem CheckThirdPartyExportStub(InstallationLocation location)
        {
            string exportLuaPath = location.ExportStubPath;
            if (!File.Exists(exportLuaPath))
            {
                return new StatusReportItem
                {
                    Status = $"The Export.lua stub does not exist at '{exportLuaPath}'",
                    Recommendation = "Generate Export.lua or create it manually",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error,
                    // writing updates won't fix this
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                };
            }

            string contents = ReadFile(exportLuaPath);
            if (!contents.Contains(EXPORT_MAIN_NAME))
            {
                return new StatusReportItem
                {
                    Status =
                        $"Helios Export script Helios\\{EXPORT_MAIN_NAME} does not appear to be called by Export.lua at '{exportLuaPath}'",
                    Recommendation = "Recreate Export.lua or edit it manually",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error,
                    // writing updates won't fix this
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                };
            }

            return new StatusReportItem
            {
                Status = $"The Export.lua stub at '{exportLuaPath}' is not generated by Helios",
                Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
            };
        }

        // NOTE: we don't factor this to share code with the other Check... functions because they are all
        // subtly different in terms of severity and we want to encourage more special cases added in the future
        private StatusReportItem CheckExportScript(InstallationLocation location)
        {
            string mainPath = location.ExportMainPath(EXPORT_MAIN_NAME);
            if (!File.Exists(mainPath))
            {
                return new StatusReportItem
                {
                    Status = $"The configured DCS export script does not exist at '{mainPath}'",
                    Recommendation =
                        "Configure the DCS interface or configure install locations correctly to locate the file",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            // NOTE: we have the entire contents we expect in this file in memory, so there is no point in hashing this
            string contents = ReadFile(mainPath);
            if (!contents.Equals(_exportMain))
            {
                return new StatusReportItem
                {
                    Status = $"The DCS export script at '{mainPath}' does not match configuration",
                    Recommendation = $"Select the interface for {_parent.VehicleName} and run DCS setup",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            return new StatusReportItem
            {
                Status = $"The configured DCS export script at '{mainPath}' is up to date",
                Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
            };
        }

        // NOTE: we don't factor this to share code with the other Check... functions because they are all
        // subtly different in terms of severity and we want to encourage more special cases added in the future
        private StatusReportItem CheckModule(InstallationLocation location)
        {
            ModuleFormatInfo moduleInfo = ExportModuleFormatInfo[_parent.ExportModuleFormat];
            switch (_parent.ExportModuleFormat)
            {
                case DCSExportModuleFormat.HeliosDriver16:
                    break;
                case DCSExportModuleFormat.CaptZeenModule1:
                    if (_parent.ExportModuleBaseName == null)
                    {
                        // no included module and we don't even know its name
                        return new StatusReportItem
                        {
                            Status = $"The {moduleInfo.DisplayName} is not included in this profile, so Helios cannot check if it is installed.",
                            Recommendation = "Please manually check that the export module was correctly placed",
                            Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                        };
                    }
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            string exportModulePath = location.ExportModulePath(moduleInfo.ModuleLocation, GenerateModuleBaseName());
            if (!File.Exists(exportModulePath))
            {
                return new StatusReportItem
                {
                    Status = $"The {moduleInfo.DisplayName} does not exist at '{exportModulePath}'",
                    Recommendation = $"Select the interface for {_parent.VehicleName} and run DCS setup",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            // NOTE: we have the entire contents we expect in this file in memory, so there is no point in hashing this
            string contents = ReadFile(exportModulePath);
            if (string.IsNullOrEmpty(_exportModuleText) || contents.Equals(_exportModuleText))
            {
                return new StatusReportItem
                {
                    Status = $"The {moduleInfo.DisplayName} at '{exportModulePath}' is up to date",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                };
            }

            return new StatusReportItem
            {
                Status =
                    $"The {moduleInfo.DisplayName} at '{exportModulePath}' does not match configuration",
                Recommendation = $"Select the interface for {_parent.VehicleName} and run DCS setup",
                Link = StatusReportItem.ProfileEditor,
                Severity = StatusReportItem.SeverityCode.Error
            };
        }

        private string GenerateModuleBaseName() =>
            _parent.ExportModuleBaseName ??
            _parent.ImpersonatedVehicleName ?? 
            _parent.VehicleName;

        // XXX if address is localhost, false
        // XXX if address is broadcast or multicast, true
        // XXX if address is address of one of our adapters, true
        private bool LocalMachineIsRemoteHelios() => false;

        #endregion
    }
}